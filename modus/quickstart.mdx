---
title: Quickstart
description: "Run your first Modus app in a few minutes"
mode: "wide"
"og:title": "Quickstart - Modus"
---

In this quickstart we'll show you how to get set up with Modus and its CLI and
build a simple app that fetches a random quote from an external API. You'll
learn how to use the basic components of a Modus app and how to run it locally.

## Prerequisites

- [Node.js](https://nodejs.org/en/download/package-manager) - v22 or higher
- Text editor - we recommend [VS Code](https://code.visualstudio.com/)
- Terminal - access Modus through a command-line interface (CLI)

## Building your first Modus app

<Steps>
  <Step title="Install the Modus CLI">
    The Modus CLI provides a set of commands to help you create, build, and run your Modus apps.
    Install the CLI using npm.

    ```bash
    npm install -g @hypermode/modus-cli
    ```

  </Step>

  <Step title="Initialize your Modus app">
    To create a new Modus app, run the following command in your terminal:

    ```bash
    modus new
    ```

    This command prompts you to choose between Go and AssemblyScript as the language for your app. It
    then creates a new directory with the necessary files and folders for your app. You will also be asked if you would like to initialize a Git repository.

  </Step>
  <Step title="Build and run your app">
    To build and run your app, navigate to the app directory and run the following command:

    ```bash
    modus dev
    ```

    This command runs your app locally in development mode and provides you with a URL to access your
    app's generated API.

  </Step>
  <Step title="Access your local endpoint">
    Once your app is running, you can access the graphical interface for your API at the URL located in your terminal.

    ```bash
    View endpoint: http://localhost:8686/explorer
    ```

    The API Explorer interface allows you to interact with your app's API and test your functions.

     <img
       className="block"
       src="../images/api-explorer.png"
       alt="API Graphical Interface."
     />

  </Step>
  <Step title="Add a connection">
    Modus is a secure-by-default framework. To connect to external services, you need to add a connection
    in your app manifest.

    Add the following code into your `modus.json` manifest file:

    ```json modus.json
    {
      "connections": {
        "zenquotes": {
          "type": "http",
          "baseUrl": "https://zenquotes.io/"
        }
      }
    }
    ```

  </Step>
  <Step title="Add a function">
    Functions are the building blocks of your app. Let's add a function that fetches a random quote from
    the ZenQuotes connection you just created.

    <Tabs>
      <Tab title="Go">
        To add a function, create a new file in the root directory with the following code:

        ```go quotes.go
        package main

        import (
          "errors"
          "fmt"

          "github.com/hypermodeinc/modus/sdk/go/pkg/http"
        )

        type Quote struct {
          Quote  string `json:"q"`
          Author string `json:"a"`
        }

        // this function makes a request to an API that returns data in JSON format, and
        // returns an object representing the data
        func GetRandomQuote() (*Quote, error) {
          request := http.NewRequest("https://zenquotes.io/api/random")

          response, err := http.Fetch(request)
          if err != nil {
            return nil, err
          }
          if !response.Ok() {
            return nil, fmt.Errorf("Failed to fetch quote. Received: %d %s", response.Status, response.StatusText)
          }

          // the API returns an array of quotes, but we only want the first one
          var quotes []Quote
          response.JSON(&quotes)
          if len(quotes) == 0 {
            return nil, errors.New("expected at least one quote in the response, but none were found")
          }
          return &quotes[0], nil
        }
        ```
      </Tab>

      <Tab title="AssemblyScript">
        To add a function, create a new file in the `assembly` directory with the following code:

        ```ts quotes.ts
        import { http } from "@hypermode/modus-sdk-as";

        @json
        class Quote {
          @alias("q")
          quote!: string;

          @alias("a")
          author!: string;
        }

        // this function makes a request to an API that returns data in JSON format, and
        // returns an object representing the data
        export function getRandomQuote(): Quote {
          const request = new http.Request("https://zenquotes.io/api/random");

          const response = http.fetch(request);
          if (!response.ok) {
            throw new Error(
              `Failed to fetch quote. Received: ${response.status} ${response.statusText}`,
            );
          }

          // the API returns an array of quotes, but we only want the first one
          return response.json<Quote[]>()[0];
        }
        ```

        Then add the following to `index.ts`. This includes the `getRandomQuote` function on
        your generated API.

        ```ts index.ts
        export * from "./quotes";
        ```

      </Tab>
    </Tabs>
    After adding your function, you can use the API Explorer interface to test the `GetRandomQuote` function.

  </Step>
  <Step title="Add a model">
    Modus also supports AI models. You can define new models in your `modus.json` file. Let's add a new meta-llama model:

      ```json
        "models": {
          "text-generator": {
            "sourceModel": "meta-llama/Meta-Llama-3.1-8B-Instruct",
            "provider": "hugging-face",
            "connection": "hypermode"
          }
        },
      ```

  </Step>
  <Step title="Install the Hyp CLI and log in">
    Next, install the Hyp CLI. This allows you to access hosted models on the Hypermode platform.

    ```bash
      npm install -g @hypermode/hyp-cli
    ```

    You can now use the `hyp login` command to log in to the Hyp CLI.
    This links your project to the Hypermode platform, allowing you to leverage the model in your modus app.

  </Step>
  <Step title="Write a function to invoke the model">
  Now we're ready to write a function to invoke the LLaMa model, hosted on Hypermode.

First, we'll import some helpers for working with model from the Modus SDK. The
LLaMa model conforms to the OpenAI model specification so we use the OpenAI chat
interface.

  <Tabs>
      <Tab title="Go">

      ```go quotes.go
        import (
          "strings"

            "github.com/hypermodeinc/modus/sdk/go/pkg/models"
            "github.com/hypermodeinc/modus/sdk/go/pkg/models/openai"

        )
        ```
      </Tab>
      <Tab title="AssemblyScript">

      ```ts index.js
      import { models } from "@hypermode/modus-sdk-as";

      import {
        OpenAIChatModel,
        SystemMessage,
        UserMessage,
      } from "@hypermode/modus-sdk-as/models/openai/chat";
      ```
      </Tab>
    </Tabs>

Now we'll write a function that takes as input an instruction and a prompt.

<Tabs>
<Tab title="Go">

```go quotes.go
  // This function generates some text based on the instruction and prompt provided.
  func GenerateText(instruction, prompt string) (string, error) {

      // The imported ChatModel type follows the OpenAI Chat completion model input format.
      model, err := models.GetModel[openai.ChatModel]("text-generator")
      if err != nil {
        return "", err
      }

      // We'll start by creating an input object using the instruction and prompt provided.
      input, err := model.CreateInput(
        openai.NewSystemMessage(instruction),
        openai.NewUserMessage(prompt),
        // ... if we wanted to add more messages, we could do so here.
      )
      if err != nil {
        return "", err
      }

      // This is one of many optional parameters available for the OpenAI chat model.
      input.Temperature = 0.7

      // Here we invoke the model with the input we created.
      output, err := model.Invoke(input)
      if err != nil {
        return "", err
      }

      // The output is also specific to the ChatModel interface.
      // Here we return the trimmed content of the first choice.
      return strings.TrimSpace(output.Choices[0].Message.Content), nil

  }
```

</Tab>

<Tab title="AssemblyScript">

```ts index.ts
/**
 * This function generates some text based on the instruction and prompt provided.
 */
export function generateText(instruction: string, prompt: string): string {
  // The imported OpenAIChatModel interface follows the OpenAI chat completion model input format.
  const model = models.getModel<OpenAIChatModel>("text-generator")

  // We'll start by creating an input object using the instruction and prompt provided.
  const input = model.createInput([
    new SystemMessage(instruction),
    new UserMessage(prompt),
    // ... if we wanted to add more messages, we could do so here.
  ])

  // This is one of many optional parameters available for the OpenAI chat model.
  input.temperature = 0.7

  // Here we invoke the model with the input we created.
  const output = model.invoke(input)

  // The output is also specific to the OpenAIChatModel interface.
  // Here we return the trimmed content of the first choice.
  return output.choices[0].message.content.trim()
}
```

</Tab>
</Tabs>

  </Step>

<Step title="Query model in API explorer">
  <img
    className="block"
    src="../images/api-explorer.png"
    alt="API Graphical Interface."
  />
</Step>

  <Step title="Chain together data and LLM call">

  <Tabs>
  <Tab title="Go">

    ```go quotes.go
    // Use an AI model to generate quote author information
    func FetchQuoteAndAuthorInfo() (quote *Quote, info *string, err error) {
      quote, err = GetRandomQuote()
      if err != nil {
        return nil, nil, err
      }

      info, err = GenerateText(fmt.Sprintf("Give me a information about %s, limit it to 1 sentence.", quote.Author))
      if err != nil {
        return nil, nil, err
      }

      return quote, info, nil
    }
    ```

  </Tab>

  <Tab title="AssemblyScript">

```ts index.ts
// TODO: write func
```

  </Tab>
  </Tabs>
  </Step>

  <Step title="Query in API explorer">
  TODO: query in API explorer

  <img
       className="block"
       src="../images/api-explorer.png"
       alt="API Graphical Interface."
     />
  </Step>
</Steps>
