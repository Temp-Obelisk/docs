---
title: AI Engineers World's Fair Workshop
description: "git push, get AI API"
---

In this workshop you’ll build a demo that augments an app with AI for classification, natural language search, and summarization. Then you’ll learn how to iteratively improve before and after shipping to prod. We’ll use Hypermode to move fast and reduce infra overhead. You’ll walk away with a greater intuition for when & how to integrate AI without refactoring.

If you need help at any point, please don't hesitate to ask.

## Prerequisites

To get the most out of this workshop, you'll need

- a GitHub account where you can create a new repo
- [Node.js 20](https://nodejs.org/) or higher installed and activated.
- an IDE such as VS Code

You can install Node.js with any supported method, including:

- Downloading the official [prebuilt installer](https://nodejs.org/en/download)
- Using a [package manager](https://nodejs.org/en/download/package-manager)

<Tip>
  Join the conversation on the [AI Engineer
  Slack](https://ai-engineer-workspace.slack.com/archives/C079FEPGY69).
</Tip>

## Agenda

We'll spend our time together on the following:

1. Playing a familiar game, using AI to scale the format
2. Understanding how the game is constructed, using both large and small models
3. Applying the same building blocks to an app triaging GitHub issues
4. Generalizing the concepts for adding AI to your apps

## Hypergories

We're going to first play a game called Hypergories, a scaled-variant of the game Scattergories. In Scattergories, players receive a list of categories and a letter. They have to come up with a unique word that fits each category and starts with the given letter.

In Hypergories, for each submission that matches the category and letter, you'll receive a point. If other submissions match yours, you'll split the point.

### Let's play

Go to \***\*\_\*\***.

### AI-powered filtering and scoring

## GitHub issue triage

We're going to apply what we learned from Hypergories to a real-world problem: triaging GitHub issues. We'll build a tool that helps you quickly understand trends, classify, and identify similar issues in their repos.

### Set up your project

Hypermode makes it easy to spin up new projects for experimentation.

- Go to [justship.ai](https://justship.ai) and select `GitHub Issue Triage`
- Click `Deploy` to start the onboarding flow
- Authenticate your account with GitHub and edit the repo name as needed
- Click `Create` to deploy your project

While your project is spinning up, personalize your workspace.

### Set up local environment

- clone the newly created GitHub repository locally.
  From the repository folder:

```sh
cd functions
npm install
npm run build
```

The build output is as follow:

```
> functions@1.2.0 build
> node ./node_modules/@hypermode/functions-as/bin/build-plugin.js

Building functions@1.2.0 in debug mode...

     __ __                                __
    / // /_ _____  ___ ______ _  ___  ___/ /__
   / _  / // / _ \/ -_) __/  ' \/ _ \/ _  / -_)
  /_//_/\_, / .__/\__/_/ /_/_/_/\___/\_,_/\__/
       /___/_/

Plugin Metadata:
  Plugin Name:     functions@1.2.0
  Library:         @hypermode/functions-as@0.9.1
  Build ID:        cptjdhnr043kifof248g
  Build Timestamp: 2024-06-25T21:29:42.152Z
  Git Repo:        https://github.com/hypermodeAI/ship-issue-triage
  Git Commit:      b40ec3e5076acaf7f53b2c3dd9c78c34d04b376a

Hypermode Functions:
  addIssue(id: string, title: string): string
  addSpam(id: string, title: string): string
  classifyIssue(id: string, title: string): string
  embedIssue(text: string[]): f32[][]
  isSpam(title: string): f32
  similarIssues(title: string): SimilarIssue[]
  trendSummary(owner: string, repo: string, since: string): string

Custom Data Types:
  SimilarIssue { id: string, title: string, similarity: f64 }
```

**What just happened?**

- Hypermode compiled the assembly scripts form our project and create a wasm module ready to be deployed on Hypermode.
- Every function exported from `index.ts` became an `Hypermode function` and will appear in the project GraphQL API.

At this stage, you can see

```
  classifyIssue(id: string, title: string): string
  trendSummary(owner: string, repo: string, since: string): string
```

**Note**
If using VS Code and see files in errors, you may need to force a reset of the typescript.

```sh
touch assembly/tsconfig.json
```

You will:

- review the code of `trendSummary` function
- review and change the function `issueClassification`
- add a new function `similarIssues`

### Trend summarization

Have a look at the function `trendSummary` in `/functions/assembly/trends.ts`

### Classify issue type

The issue classification function is located in `/functions/assembly/classify.ts`

```typescript
export function classifyIssue(id: string, title: string): string {
  const model = models.getModel<ClassificationModel>("issue-classifier");
  const input = model.createInput([title]);
  const output = model.invoke(input).predictions[0];

  return output.label;
}
```

### Find similar issues

In order to find similar issues base on title we need to

- declare a collection to store issues
- instruct Hypermode to compute a vector embedding using a model
- create an Hypermode function returning similar issues based on a provided title.

#### Declare a Collection in `hypermode.json` manifest file.

Add the following section in hypermode.json:

```
  "collections": {
    "issuesCollection": {
      "searchMethods": {
        "byTitle": {
          "embedder": "minilmEmbedder"
        }
      }
    }
  }
```

In order to compute vector embedding we will also need a model.

Simply add a model declaration in hypermode.json file, under the `models` section:

```
"minilm": {
      "sourceModel": "sentence-transformers/all-MiniLM-L6-v2",
      "host": "hypermode",
      "provider": "hugging-face"
    }
```

Hypermode.json file should now be

```
{
  "$schema": "https://manifest.hypermode.com/hypermode.json",

  "models": {
    "issue-classifier": {
      "sourceModel": "AntoineMC/distilbart-mnli-github-issues",
      "provider": "hugging-face",
      "host": "hypermode"
    },
    "text-generator": {
      "sourceModel": "gpt-3.5-turbo",
      "host": "openai",
      "path": "v1/chat/completions"
    },
    "minilm": {
      "sourceModel": "sentence-transformers/all-MiniLM-L6-v2",
      "host": "hypermode",
      "provider": "hugging-face"
    }
  },

  "hosts": {
    "github": {
      "baseUrl": "https://api.github.com/",
      "headers": {
        "Authorization": "Bearer {{AUTH_TOKEN}}"
      }
    },
    "openai": {
      "baseUrl": "https://api.openai.com/",
      "headers": {
        "Authorization": "Bearer {{API_KEY}}"
      }
    }
  },

  "collections": {
    "issuesCollection": {
      "searchMethods": {
        "byTitle": {
          "embedder": "minilmEmbedder"
        }
      }
    }
  }
}

```

#### Write the embedding function

Add a file `embedder.ts`in the`functions/assembly` folder.

```
import { models } from "@hypermode/functions-as";
import { EmbeddingsModel } from "@hypermode/models-as/models/experimental/embeddings";

export function minilmEmbedder(text: string[]): f32[][] {
  const model = models.getModel<EmbeddingsModel>("minilm");
  const input = model.createInput(text);
  const output = model.invoke(input);

  return output.predictions;
}
```

#### Write `similarIssues` function

Let's create `similar.ts` file and declare a function to return similarIssues from the collection.

```typescript
import { collections } from "@hypermode/functions-as";

// Define the structure we expect for the output of the similarity search function.
@json
export class SimilarIssue {
  id!: string;
  title!: string;
  similarity!: f64;
}

export function similarIssues(title: string): SimilarIssue[] {
  const response = collections.search(
    "issuesCollection",
    "byTitle",
    title, // the text to search for
    3, // return the top 3 results
    true, // include text in the results
  );

  return response.objects.map<SimilarIssue>(
    (o) =>
      <SimilarIssue>{
        id: o.key,
        title: o.text,
        similarity: o.score,
      },
  );
}
```

### Production-ready API

## What's next

You can apply the building blocks of filtering, summarization, categoriation, and search into a wide variety of apps.

For further inspiration, explore [justship.ai](https://justship.ai) and deploy today!
